---
tag:
- C
---
Динамическая память в Си - это память, выделяемая во время выполнения программы, в отличие от статической памяти, которая выделяется на этапе компиляции.

В языке C существуют **два основных вида** динамической памяти: динамический массив и динамические структуры данных.

1. Динамический массив: Динамический массив создается с использованием функции `malloc()`, `calloc()` или `realloc()`, которые позволяют выделить память для массива переменного размера.

- `malloc()` выделяет блок памяти указанного размера и возвращает указатель на начало этого блока.
- `calloc()` выделяет блок памяти указанного размера и инициализирует каждый байт в блоке нулевым значением.
- `realloc()` изменяет размер уже выделенного блока памяти. Он может быть использован для увеличения или уменьшения размера блока памяти.

Пример использования `malloc()` для создания динамического массива:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    int* arr;

    printf("Введите размер массива: ");
    scanf("%d", &n);

    arr = (int*)malloc(n * sizeof(int));
    if (arr == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    // Использование динамического массива

    free(arr);
    return 0;
}
```

2. Динамические структуры данных: Динамические структуры данных включают связанные списки, деревья, хеш-таблицы и другие структуры данных, которые создаются и изменяются во время выполнения программы.

Пример использования динамической структуры данных (связанного списка) с использованием `malloc()`:

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

int main() {
    struct Node* head = NULL;
    struct Node* newNode = NULL;

    // Создание нового узла
    newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    // Добавление данных в узел
    newNode->data = 10;
    newNode->next = NULL;

    // Установка нового узла в качестве головы списка
    head = newNode;

    // Использование динамической структуры данных

    free(newNode);
    return 0;
}
```

В этом примере создается связанный список, и каждый узел выделяется динамически с помощью `malloc()`. Затем в узле хранятся данные и связи между узлами. После использования динамической структуры данных память освобождается с помощью `free()`.

Для выделения динамической памяти в Си используется функция malloc(). Она возвращает указатель на выделенную память:

```c
int *p = (int *)malloc(sizeof(int));
```


Чтобы освободить выделенную память, используется функция free():

```c
int *p = (int *)malloc(sizeof(int)); // использование p free(p);
```


В Си также есть функция calloc(), которая выделяет память и инициализирует ее нулями.

Использование динамической памяти позволяет создавать переменные или массивы произвольного размера во время выполнения программы, что может быть полезно в случаях, когда размер данных неизвестен заранее.

Вот несколько примеров использования функции `malloc` в Си:

Выделение памяти для одной переменной
---

```c
int *p = (int *)malloc(sizeof(int));
if (p == NULL) {
    // Обработка ошибки
}
// Использование p
free(p);

```

Выделение памяти для массива
---

```c
int n = 10;
int *a = (int *)malloc(n * sizeof(int));
if (a == NULL) {
    // Обработка ошибки
}
for (int i = 0; i < n; i++) {
    a[i] = i;
}
// Использование a
free(a);

```

Выделение памяти для структуры
---
[Структкры](Структкры.md)

```c
struct Point {
    int x;
    int y;
};
struct Point *p = (struct Point *)malloc(sizeof(struct Point));
if (p == NULL) {
    // Обработка ошибки
}
p->x = 1;
p->y = 2;
// Использование p
free(p);

```

Обратите внимание, что после выделения памяти с помощью `malloc`, ее необходимо освободить с помощью `free`, иначе возможно утечка памяти.

---

Функции `malloc` и `calloc` используются для динамического выделения памяти в языке программирования C. Они служат похожим целям, но существуют определенные различия в их работе:

1. `void *malloc(size_t size)`: Эта функция принимает один аргумент - количество байтов для выделения. Она выделяет блок памяти заданного размера и возвращает указатель на первый байт выделенного блока. Обратите внимание, что `malloc` не инициализирует блок памяти, то есть блок может содержать "мусор" - случайные данные, которые были в этом месте памяти ранее.

2. `void *calloc(size_t num, size_t size)`: Эта функция принимает два аргумента - количество элементов для выделения и размер каждого элемента в байтах. Она выделяет блок памяти, достаточный для хранения указанного числа элементов заданного размера, и возвращает указатель на первый байт выделенного блока. Важное отличие от `malloc` в том, что `calloc` автоматически инициализирует выделенный блок памяти нулями.

В общем, можно использовать `malloc` для выделения блока памяти без инициализации, в то время как `calloc` можно использовать для выделения блока памяти с автоматической инициализацией нулями. Обе функции возвращают `NULL`, если операционная система не может удовлетворить запрос на выделение памяти.