---
tag:
- C
- C/Указатели
---
`int a;` - целочисленная переменная a
`int* b;` -  в оперативной памяти размещается переменная б типа указатель для хранения адреса, на целочисленные данные. Аналог: int *b,c;
`a=5;` - в ячейку памяти переменной а помещается 5
`b=&a;` - в б переменной сохраняется адрес а (& взятие адреса)
`*b=10;` - взятие данных (разыменование данных) по адресу хоронящемся в б записать 10  (a=10).
`*(&a)  = a * b &` друг друга сокращают
`int **c;     int ***d;`
`c=&b;     d=&c;`
`a**b  = a^2`

```c
void main() {
    int a = 2;      // a == 2
    int b = 4;      // b == 4
    int *p = 0;     // p == 0
    p = &a;         // p == адрес переменной a
    *p = 3;         // a == 3... или нет?
    p++;            // p == адрес переменной b ??!?!?
    (*p)++;         // b == 5 O_o WTF
    *p = *(p - 1);  // b == a == 3 ...
}
```

```c
#include <stdio.h>

int main() {
    int a[10];
    // int array_z[2][3] = {{1, 2, 3}, {4, 5, 6}}; // 2 мерный массив
    int array_z[3] = {1, 2, 3};
    // a[2] == *(a + 2) == *(2 + a) == 2 [a];
    // a[2] == 2 [a];
    // *(a + 2) == *(2 + a);
    a[2] = 5;
    int *b = &a[2];
    int *c = a + 2;
    int *e = 2 + a;
    int *d = &2 [a];
    printf("%p\n", b);
    printf("%p\n", c);
    printf("%p\n", e);
    printf("%p\n", d);
    printf("%d\n", a[2]);
    printf("%d\n", 2 [a]);
    // if (&a[10] == &10 [a]) printf("1\n"); //
    printf("\n---\n");

    for (int i = 0; i < 3; i++) {
        // printf("%d\n", *(array_z + i));
        printf("%p\n", &array_z[i]);
        printf("%d\n", array_z[i]);
        // printf("%d\n", i[array_z]);
    }
    return 0;
}

```

```txt
0x7ffee9706698
0x7ffee9706698
0x7ffee9706698
0x7ffee9706698
5
5
---
0x7ffee9706684
1
0x7ffee9706688
2
0x7ffee970668c
3
```

ПОМНИ!
- В языке `С` - массивов не существует!
- `int a[10]` - это не массив!

Допустимые операции над типизированным указателем:
*(может хотя бы так я это запомню)*
- Получение адреса
- Разыменование указателя
- Сложение с числом
- Вычитание указателей
- Сравнение указателей
- Логические операции над указателями
- Присваивание указателей

**Задачи:**
- Передача данных из и в функции
- Динамическое выделение памяти
- Нетепезированный указатель
- void* (f*) (void*) - пустой тип данных. Просто какой то адрес.

Указатели - это переменные, показывающие место или адрес памяти, где расположены другие объекты (переменные, функции и др.). Так как указатель содержит адрес некоторого объекта, то через него можно обращаться к этому объекту.
 Унарная операция & дает адрес объекта, поэтому оператор
`у = &х;`
 присваивает адрес переменной х переменной у. Операцию & нельзя применять к константам и выражениям; конструкции вида &(х+7) или &28 недопустимы.
 Унарная операция * воспринимает свой операнд как адрес некоторого объекта и использует этот адрес для выборки содержимого, поэтому оператор
 `z = *y;`
 присваивает z значение переменной, записанной по адресу у. Если

```c
y = &x;
z = *у;
```

 то `z = x`.
 Объекты, состоящие из знака * и адреса (например, *а), необходимо определить. Делается это, например, так:
 ```c
int *а, *b, *с;
char *d;
```

 Определение вида char *d говорит о том, что значение, записанное по адресу d, имеет тип char.
 Указатели могут встречаться и в выражениях. Если у - указатель на целое, т.е. имело место объявление int *у, то *у может появиться там же, где и любая другая переменная, не являющаяся указателем. Таким образом, следующие выражения вполне допустимы:
 ```c
*у = 7;
*x *=5;
(*z)++;
```
 Первое из них заносит число 7 в ячейку памяти по адресу у, второе увеличивает значение по адресу х в пять раз, третье добавляет единицу к содержимому ячейки памяти с адресом z. В последнем случае круглые скобки необходимы, так как операции с одинаковым приоритетом выполняются справа налево. В результате если, например, *z = 5, то (*z)++ приведет к тому, что *z = 6, а *z++ всего лишь изменит сам адрес z (операция ++ выполняется над адресом z, а не над значением *z по этому адресу).
 Указатели можно использовать как операнды в арифметических операциях. Если у - указатель, то унарная операция y++ увеличивает его значение; теперь оно является адресом следующего элемента. Указатели и целые числа можно складывать. Конструкция у + n (у - указатель, n - целое число) задает адрес n-гo объекта, на который указывает у. Это справедливо для любых объектов (int, char, float и др.); транслятор будет масштабировать приращение адреса в соответствии с типом, указанным в определении объекта.
 Любой адрес можно проверить на равенство (==) или неравенство (!=) со специальным значением NULL, которое позволяет определить ничего не адресующий указатель.
