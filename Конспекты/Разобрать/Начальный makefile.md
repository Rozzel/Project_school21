[make](http://ru.wikipedia.org/wiki/Make) — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:

1.  целями (то, что данное правило делает);
2.  реквизитами (то, что необходимо для выполнения правила и получения целей);
3.  командами (выполняющими данные преобразования).

```makefile
# Makefile
цель1: # название_цели
    команда1 # Обратите внимание — все команды, обязаны содержать в начале символ табуляции — так инструмент сборки отслеживает правила и другие цели
    команда2 # если предыдущая команда была успешно выполнена, начинает выполняться следующая команда и так далее
```


```makefile
{Из чего делаем? (реквизиты)} --->
[Как делаем? (команды)] --->
{Что делаем? (цели)}
```

Предположим у нас есть простейшая программа состоящая из одного файла:

```c
#include <stdio.h>

int main() {
  printf("Hello, AI!");
  return 0;
}
```

Для его компиляции достаточно очень простого мэйкфайла:

```makefile
hello: main.c
	gcc -o hello main.c
```

Данный Makefile состоит из одного правила, которое в свою очередь состоит из:
цели — «hello»,
реквизита — «main.c»,
команды — «gcc -o hello main.c».

Теперь, для компиляции достаточно дать команду make в рабочем каталоге. По умолчанию make станет выполнять самое первое правило, если цель выполнения не была явно указана при вызове

В результате получим готовую программу hello

`run hello`

А теперь сразу повысим сложность, добавив алиасы (переменные)

```makefile
CC = gcc # Компилятор
LDFLAGS = -Wall -Wextra -Werror -std=c11 # Флаги при компиляции

hello: main.c
	${CC} ${LDFLAGS} -o $@ $^ # Автоподстановка имени для результата и реквизита используя "Автоматические переменные"
```

Результат работы такого мэйкфайла не измениться.

-   Но разберем его подробней, а именно автоматические переменные:
    
    **$@ = hello**, данная переменная равняется названию цели.
    
    **$^ = main.c**, данная переменная равняется имени всех реквизитов, если их будет несколько значит при компиляции подставиться имена всех.
    
    [Полный перечень автоматических переменных](https://www.gnu.org/software/make/manual/make.html#Automatic-Variables)
    

А теперь научим наш мэйкфайл проверять стилистику кода и добавим проверку кода до компиляции

```makefile
CC = gcc
LDFLAGS = -Wall -Wextra -Werror -std=c11

all: check hello

hello: main.c
	${CC} ${LDFLAGS} -o $@ $^

check: main.c
	python ../materials/linters/cpplint.py --extensions=c $^
```

Но что, если мы забыли положить _**CPPLINT.cfg**_ в папку с исходниками.... Добавим условную конструкцию _**ifeq**_, для проверки существования файла через шаблонные символы (wildcard)

[make](http://ru.wikipedia.org/wiki/Make) — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:

1.  целями (то, что данное правило делает);
    
2.  реквизитами (то, что необходимо для выполнения правила и получения целей);
    
3.  командами (выполняющими данные преобразования).
    

```makefile
check: main.c
ifeq ("","$(wildcard ./CPPLINT.cfg)") # если файла нет, копируем его.
	cp -f ../materials/linters/CPPLINT.cfg ./CPPLINT.cfg
endif
	python ../materials/linters/cpplint.py --extensions=c $^
```

> Все условные конструкции (во всех формах - ifdef, ifeq, ifndef и ifneq) целиком и полностью обрабатываются "немедленно". И должны начинаться с новой строки.

Добавим цель очистки, которая будет удалять нашу программу или артефакты после компиляции

```makefile
CC = gcc
LDFLAGS = -Wall -Wextra -Werror -std=c11

all: check hello

hello: main.c
	${CC} ${LDFLAGS} -o $@ $^

check: main.c
ifeq ("","$(wildcard ./CPPLINT.cfg)") # если файла нет, копируем его.
	cp -f ../materials/linters/CPPLINT.cfg ./CPPLINT.cfg
endif
	python ../materials/linters/cpplint.py --extensions=c $^
clean: 
	rm -f hello
```

Теперь вызывая _**make clean**_ будет удален результат компиляции, но что делать с назойливой ошибкой при повторном вызове цели...

> Для того, чтобы проигнорировать ошибки в команде, поместите в начало строки (после символа табуляции), где она описана, символ `-' . Перед тем, как эта команда будет передана интерпретатору командной строки, символ` -'  будет из нее удален.

```makefile
clean: 
	-rm -f hello
```
